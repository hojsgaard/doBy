% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/specialize.R
\name{specialize}
\alias{specialize}
\title{specialize}
\usage{
specialize(FUN, arglist, envir = parent.frame())
}
\arguments{
\item{FUN}{Function}

\item{arglist}{List of the form name=value}

\item{envir}{Environment}
}
\value{
A list
}
\description{
Fix certain arguments of a function call thereby
  creating a new function defined on a smaller domain (hence the
  name specialize).
}
\details{
The `curry::partial` function does the same as `specialize`, except that an error is produced 
   if the function to be curried takes only one argument. Moreover (at the time of writing: April 2021), 
   the most recent update of `curry` in CRAN was in 2016.
}
\examples{

f1 <- function(x, y){x+y}
f1_ <- specialize(f1, list(y=100))
f1_(100)

f2 <- function(x){
  x <- x + 2
  x
}
f2_ <- specialize(f2, list(x=100)) # Absurd
f2_

f1 <- function(n) {
  x <- seq_len(n)
  s <- 0
  for (i in x) s <- s + x[i]
  s
}

f2 <- function(n, y) {
  f1(n) + y
}

# Specialize
f1_ <- specialize(f1, list(n=100))
f1_
f1_()

# Sequential or once and for all specilization
f2_ <- specialize(f2, list(y=1000)); f2_
f2_ <- specialize(f2_, list(n=100)); f2_
f2_()
f2_ <- specialize(f2, list(n=100, y=1000)); f2_
f2_()

# Example: benchmarking
n.list  <- list(10000, 100000)
f2 <- specialize(f2, list(y=1000))
f1.list <- lapply(n.list, function(a.) specialize(f1, list(n=a.)))
f2.list <- lapply(n.list, function(a.) specialize(f2, list(n=a.)))

dobq <- function(fnlist){
  lapply(fnlist, function(g) bquote(.(g)()))
}

a1 <- dobq(f1.list)
a2 <- dobq(f2.list)

if (require(microbenchmark)){
  microbenchmark(list = c(a1, a2))
}

}
\author{
Søren Højsgaard, \email{sorenh@math.aau.dk}
}
