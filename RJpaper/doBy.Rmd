---
title: The `doBy` package -- yet another utility package
author:
  - name: Søren Højsgaard
    affiliation: Department of Mathematical Sciences, Aalborg University, Denmark
    address:
    - Skjernvej 4A
    - 9220 Aalborg Ø, Denmark
    email: sorenh@math.aau.dk
abstract: > 
  The `doBy` is one of several general utility packages on CRAN. We illustrate two main
  features of the package. The ability to making groupwise computations and the ability
  to compute linear estimates, contrasts and least-squares means.
preamble: |
  % Any extra LaTeX you need in the preamble
output: |
  rticles::rjournal_article
---

  <!-- pdf_document: -->
  <!--   fig_caption: yes -->
  <!--   keep_tex: true -->
  <!--   toc: true -->
  <!--   toc_depth: 3 -->
  <!--   number_sections: true -->

<!-- %%% output: rticles::rjournal_article -->


```{r, echo=FALSE}
library(ggplot2)
library(doBy)
library(magrittr)
options("digits"=4)
```


## Introduction

The `doBy` package [@doby] appeared on CRAN in 2006 and, much
to our surprise, the package is still being used.  The package
originally grew out of a need to calculate groupwise summary
statistics (much in the spirit of `PROC SUMMARY` of the `SAS` system,
[@procsummary]). The name comes from the need to __do__ some computations on data which is 
stratified __By__ the value of some variables.  Today the
package contains many different utilities.
When it comes to data handling, `doBy` is nowhere nearly as powerful as more contemporary packages, e.g. those in the `tidyverse` eco system, [@tidyverse]. On the other hand, it can be hypothesized that the data handling functions in `doBy` remain appealing group of users because of their simplicity in use.
In this paper we focus 1)
on the "doing by" functions and 2) on functions related to linear
estimates and contrasts. 


## Functions related to groupwise computations

### A working dataset

The `CO2` data frame comes  from an
experiment on the cold tolerance of the grass species _Echinochloa
crus-galli_.
To limit the amount of output we modify names and levels of variables
as follows

```{r}
data(CO2)
CO2 <- within(CO2, {
    Treat <- Treatment
    Treatment <- NULL
    levels(Treat) <- c("nchil", "chil")
    levels(Type)  <- c("Que", "Mis")
})
CO2 <- subset(CO2, Plant %in% c("Qn1", "Qc1", "Mn1", "Mc1"))
dim(CO2)
head(CO2, 4)
```

### The `summaryBy` function

The `summaryBy` function is used for calculating quantities like _the
mean and variance of numerical variables `x` and `y` for each
combination of two factors `A` and `B$`_.  Notice: A functionality
similar to `summaryBy` is provided by `aggregate` from base R, but `summaryBy` offers additional features. 


```{r}
myfun1 <- function(x){c(m=mean(x), s=sd(x))}
summaryBy(cbind(conc, uptake, lu=log(uptake)) ~ Plant, data=CO2, FUN=myfun1)
## same as
## aggregate(cbind(conc, uptake, log(uptake)) ~ Plant, data=CO2, FUN=myfun1)
```

The convention is that variables that do not appear in the dataframe (e.g. `log(uptake)`) must be named (here as `lu`). 
Various convenient abbreviations are available, e.g. the following, where 
left hand side dot refers to "all numeric variables" while the
right hand side dot refers to "all factor variables". Writing `1` on the right hand side leads to computing over the entire dataset:

```{r}
summaryBy(. ~ ., data=CO2, FUN=myfun1)
summaryBy(. ~ 1, data=CO2, FUN=myfun1)
```


### Formulas and lists

It is generally the case for the "By"-functions that a two sided formula like can be written in two ways:
```{r, eval=FALSE}
cbind(x, y) ~ A + B
list(c("x", "y"), c("A", "B"))
```

Some "By"-functions only take a right hand sided formula as input. Such a formula can also be written in two ways:
```{r, eval=FALSE}
~ A + B
c("A", "B")
```

The list-form / vector-form is especially useful if a function is invoked programatically. Hence the calls to `summaryBy` above can also be made as

```{r, eval=FALSE}
summaryBy(list(c("conc", "uptake", "lu=log(uptake)"), "Plant"), data=CO2, FUN=myfun1)
summaryBy(list(c("."), c(".")), data=CO2, FUN=myfun1)
summaryBy(list(c("."), c("1")), data=CO2, FUN=myfun1)
```


### The `orderBy` function

Ordering (or sorting) a data frame is possible with the `orderBy`
function.  Suppose we want to order the rows of the the `CO2` data by
increasing values of `conc` and decreasing value of `uptake` (within `code`):
```{r}
x1 <- orderBy(~ conc - uptake, data=CO2)
head(x1, 4)
```

Following the remarks on specification in "By"-functions, an equivalent form is:
```{r, eval=F}
orderBy(c("conc", "-uptake"), data=CO2) 
```

### The `splitBy` function

Suppose we want to split `CO2` into a list of dataframes:

```{r}
x1 <- splitBy(~ Plant + Type, data=CO2)
x1
```

The result is a list (with a few additional attributes):
```{r}
lapply(x1, head, 2)
```

### The `subsetBy` function


Suppose we want to select those rows within each treatment for which  the
uptake is larger than 75% quantile of uptake (within the treatment). This
is achieved by:

```{r}
x2 <- subsetBy(~ Treat, subset=uptake > quantile(uptake, prob=0.75), data=CO2)
head(x2, 4)
```

### The `transformBy` function

The `transformBy` function is analogous to the `transform`
function except that it works within groups. For example:

```{r}
x3 <- transformBy(~ Treat, data=CO2, 
                 minU=min(uptake), maxU=max(uptake),
                 range=diff(range(uptake)))
head(x3, 4)
```

### The `lmBy` function

The `lmBy` function allows for fitting linear models to different strata of data:
```{r}
m <- lmBy(uptake ~ conc | Treat, data=CO2)
coef(m)
```

The result is a list with a few additional attributes and the list can be processed further as e.g.
```{r}
lapply(m, function(z) coef(summary(z)))
```


## Functions related linear estimates and contrasts

A linear function of a $p$--dimensional parameter vector $\beta$ has
the form
\begin{displaymath}
  C=L\beta
\end{displaymath}
where $L$ is a $q\times p$ matrix which we call the `Linear Estimate Matrix` or 
simply `LE-matrix`.  The corresponding
linear estimate is $\hat C = L \hat \beta$.  A linear hypothesis has
the form $H_0: L\beta=m$ for some $q$ dimensional vector $m$.


### A working dataset

The response is the length of odontoblasts cells (cells responsible for
tooth growth) in 60 guinea pigs.  Each animal received one of
three dose levels of vitamin C (0.5, 1, and 2 mg/day) by one of
two delivery methods, (orange juice (coded as OJ) or ascorbic acid 
(a form of vitamin C and (coded as VC)).

```{r}
ToothGrowth$dose <- factor(ToothGrowth$dose)
head(ToothGrowth, 4)
```


<!-- An **interaction plot** is a graphical visualization of the group -->
<!-- averages, see where also variability -->
<!-- in each group is displayed: -->

```{r linear:interaction2, echo=F, fig.height=2, fig.cap="Interaction plot for the ToothGrowth data. The average `len` for each group is a dot. Boxplot outliers are crosses."}
toothInt <- summaryBy(len ~ dose + supp, data=ToothGrowth)
ggplot(ToothGrowth, aes(x = factor(dose), y = len, colour = supp)) +
    geom_boxplot(outlier.shape = 4) +
    geom_point(data = toothInt, aes(y = len.mean)) +
    geom_line(data = toothInt, aes(y = len.mean, group = supp))
```

The interaction plot indicates some interaction between `dose` and `supp`.
This is also supported by a formal test:
```{r}
tooth1 <- lm(len ~ dose + supp, data=ToothGrowth)
tooth2 <- lm(len ~ dose * supp, data=ToothGrowth)
anova(tooth1, tooth2)
```

### Computing linear estimates

For now, we focus on the additive model. 
Consider computing the estimated length for each dose of orange juice (OJ):
One option: Construct the LE--matrix $L$ directly and then invoke `linest`:

```{r}
L <- matrix(c(1, 0, 0, 0, 
              1, 1, 0, 0,
              1, 0, 1, 0), nrow=3, byrow=T)
c1 <- linest(tooth1, L)
c1
```

We can do:

```{r}
summary(c1)
coef(c1)
confint(c1)
```


The matrix $L$ can be generated as follows:
```{r}
L <- LE_matrix(tooth1, effect="dose", at=list(supp="OJ"))
L
```


There are various alternatives:
```{r}
c1 <- esticon(tooth1, L)
c1
```

Yet another
alternative in this case is to generate a new data frame and then
invoke predict (but this approach is not generally applicable, see later):

```{r}
nd <- data.frame(dose=c('0.5', '1', '2'), supp='OJ')
nd
predict(tooth1, newdata=nd)
```


### Least-squares means (LS--means)

A related question could be: What is the estimated length for each
dose if we ignore the source of vitamin C (i.e.\ whether it is OJ or
VC). One approach would be to fit a model in which source does not appear:

```{r}
tooth0 <- update(tooth1, . ~ . - supp)
L0 <- LE_matrix(tooth0, effect="dose")
L0
linest(tooth0, L=L0)
```

An alternative would be to stick to the original model but compute the
estimate for an ``average vitamin C source''. That would correspond to
giving weight $1/2$ to each of the two vitamin C source
parameters. However, as one of the parameters is already set to zero
to obtain identifiability, we obtain the LE--matrix $L$ as

```{r}
L1 <- matrix(c(1, 0, 0, 0.5, 
               1, 1, 0, 0.5,
               1, 0, 1, 0.5), nrow=3, byrow=T)
linest(tooth1, L=L1)
```

Such a particular linear estimate is sometimes called a least-squares
mean or an LSmean or a marginal mean. Notice that the parameter
estimates under the two approaches are identical. This is is because
data is balanced: There are $10$ observations per supplementation
type. Had data not been balanced, the estimates would in general have been different. 

Notice: One may generate $L$ automatically with
```{r}
L1 <- LE_matrix(tooth1, effect="dose")
L1
```

Notice: One may obtain the LSmean directly as:

```{r}
LSmeans(tooth1, effect="dose")
```

which is the same as

```{r}
L <- LE_matrix(tooth1, effect="dose")
le <- linest(tooth1, L=L)
coef(le)
```

### Interaction model

For a model with interactions, the LSmeans are
```{r}
LSmeans(tooth2, effect="dose")
```

In this case, the LE--matrix is
```{r}
L <- LE_matrix(tooth2, effect="dose")
t(L)

```



### Using (transformed) covariates

Below, the covariate `conc` is fixed at the average value:
```{r}
co2.lm1 <- lm(uptake ~ conc + Type + Treat, data=CO2)
LSmeans(co2.lm1, effect="Treat")
```

If we use `log(conc)` instead we will get an error when
calculating LS--means because `log(conc)` is not a variable in the dataframe. 
Instead one can do:
```{r}
co2.lm2 <- lm(uptake ~ log.conc + Type + Treat,
             data=transform(CO2, log.conc=log(conc)))
LSmeans(co2.lm2, effect="Treat")
```

This also highlights what is computed: The average of the log of
`conc`; not the log of the average of `conc`.
In a similar spirit consider

```{r}
co2.lm3 <- lm(uptake ~ conc + I(conc^2) + Type + Treat, data=CO2)
LSmeans(co2.lm3, effect="Treat")
```

Above \verb'I(conc^2)' is the average of the squared values of
`conc`; not the  square of the average of
`conc`, cfr.\ the following.

```{r}
co2.lm4 <- lm(uptake ~ conc + conc2 + Type + Treat, data=
              transform(CO2, conc2=conc^2))
LSmeans(co2.lm4, effect="Treat")
```

If we want to evaluate the LS--means at `conc=10` then we can do:
```{r}
LSmeans(co2.lm4, effect="Treat", at=list(conc=10, conc2=100))
```


## Alternative models

### Generalized linear models

We can calculate LS--means for e.g.\ a Poisson or a gamma model. Default is that
the calculation is calculated on the scale of the linear
predictor. However, if
we think of LS--means as a prediction on the linear scale one may
argue that it can also make sense to transform this prediction to
the response scale:

```{r}
tooth.gam <- glm(len ~ dose + supp, family=Gamma, data=ToothGrowth)
LSmeans(tooth.gam, effect="dose", type="link")
LSmeans(tooth.gam, effect="dose", type="response")
```


### Linear mixed effects model

For the sake of illustration we treat \verb|supp| as a random effect:
```{r}
library(lme4)
tooth.mix <- lmer( len ~ dose  + (1|supp), data=ToothGrowth)
LSmeans(tooth1, effect="dose")
LSmeans(tooth.mix, effect="dose")
```

Notice here that the estimates themselves identical to those of a
linear model (that is not generally the case, but it is so here
because data is balanced). In general the estimates are will be 
very similar but the standard errors are much larger under the mixed model.
This comes from that
there that `supp` is treated as a random effect.
```{r}
VarCorr(tooth.mix)
```

Notice that the degrees of freedom by default are adjusted using a
Kenward--Roger approximation (provided that `pbkrtest` is
installed). Unadjusted degrees of freedom are obtained by setting \verb|adjust.df=FALSE|. 
```{r}
LSmeans(tooth.mix, effect="dose", adjust.df=FALSE)
```

<!-- % Notice that the degrees of freedom by default are adjusted using a -->
<!-- % Kenward--Roger approximation (provided that `pbkrtest` is -->
<!-- % installed). Unadjusted degrees of freedom are obtained with -->
<!-- % <<>>= -->
<!-- % LSmeans(warp.mm, effect="tension", adjust.df=FALSE) -->
<!-- % @ %def -->

### Generalized estimating equations

Lastly, for gee-type ``models'' we get
```{r}
library(geepack)
tooth.gee <- geeglm(len ~ dose, id=supp, family=Gamma, data=ToothGrowth)
LSmeans(tooth.gee, effect="dose")
LSmeans(tooth.gee, effect="dose", type="response")
```



## Acknowledgements

Credit is due to Dennis Chabot, Gabor Grothendieck, Paul Murrell, Jim
Robison-Cox and Erik Jørgensen for reporting various bugs and
making various suggestions to the functionality in the `doBy`
package.



\bibliography{RJreferences}


<!-- ## Summary -->

<!-- This file is only a basic article template. For full details of _The R Journal_ style and information on how to prepare your article for submission, see the [Instructions for Authors](https://journal.r-project.org/share/author-guide.pdf). -->




<!-- ```{r} -->

<!-- mtcars <- within(mtcars, { -->
<!--    vs <- factor(vs, labels = c("V", "S")) -->
<!--    am <- factor(am, labels = c("auto", "man")) -->
<!-- }) -->
<!-- mtcars$drat <- mtcars$disp <- mtcars$wt <- mtcars$carb <- mtcars$gear <- NULL -->
<!-- mtcars <- subset(mtcars, cyl < 8) -->
<!-- mtcars %>% head -->
<!-- ``` -->





<!-- ```{r} -->
<!-- library(doBy) -->
<!-- summaryBy(cbind(mpg, qsec) ~ cyl + vs, data=mtcars) -->

<!-- summaryBy(list(c("mpg", "qsec"), c("cyl", "vs")), data=mtcars) -->

<!-- summaryBy(. ~ cyl + vs, data=mtcars) -->

<!-- summaryBy(. ~ ., data=mtcars) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- ss <- splitBy(~ vs, data=mtcars) -->
<!-- ss -->
<!-- ss$V -->
<!-- ``` -->


<!-- Introductory section which may include references in parentheses -->
<!-- [@R], or cite a reference such as @R in the text. -->

<!-- This section may contain a figure such as Figure \ref{fig:Rlogo}. -->

<!-- ```{r, Rlogo, echo=FALSE, fig.cap='The logo of R.', out.width='2in', fig.align='center', fig.pos='htbp'} -->
<!-- knitr::include_graphics('Rlogo.pdf') -->
<!-- ``` -->

<!-- There will likely be several sections, perhaps including code snippets, such as: -->

<!-- ```{r} -->
<!-- x <- 1:10 -->
<!-- x -->
<!-- ``` -->
