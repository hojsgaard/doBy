---
title: The `doBy` package -- yet another utility package
author:
  - name: Søren Højsgaard
    affiliation: Department of Mathematical Sciences, Aalborg University, Denmark
    address:
    - Skjernvej 4A
    - 9220 Aalborg Ø, Denmark
    email: sorenh@math.aau.dk
abstract: > 
  The `doBy` is one of several general utility packages on CRAN. We illustrate two main
  features of the package: The ability to making groupwise computations and the ability
  to compute linear estimates, contrasts and least-squares means.
preamble: |
  % Any extra LaTeX you need in the preamble
output: |
  rticles::rjournal_article
---

  <!-- pdf_document: -->
  <!--   fig_caption: yes -->
  <!--   keep_tex: true -->
  <!--   toc: true -->
  <!--   toc_depth: 3 -->
  <!--   number_sections: true -->

<!-- %%% output: rticles::rjournal_article -->




```{r echo=FALSE, results="hide", messages=FALSE}
knitr::opts_chunk$set(fig.path="fig/doby-", tidy=FALSE,
                      cache=!TRUE,
                      fig.width=5, fig.height=2.5, size="small", out.extra='keepaspectratio')
options("show.signif.stars"=FALSE)
options("digits"=4)
suppressPackageStartupMessages({
library(ggplot2)
library(doBy)
library(Matrix)
library(lme4)
library(magrittr)
library(tidyverse);
library(broom)
})
```





## Introduction

The package
originally grew out of a need to calculate groupwise summary
statistics (much in the spirit of `PROC SUMMARY` of the `SAS` system,
[@procsummary]). The name `doBy` comes from the need to __do__ some computations on data which is 
stratified __By__ the value of some variables.  The `doBy` package [@doby] appeared on CRAN in 2006.
Today the
package contains many additional utilities. 

When it comes to data handling, `doBy` is nowhere nearly as powerful as more contemporary packages, such as those in the `tidyverse` eco system, [@tidyverse]. On the other hand, `doBy` is based on classical data structures that are unlikely to undergo sudden changes. Moreover, 
it can be hypothesized that the data handling functions in `doBy` remain appealing to a group of users because of their simplicity in use. 

In this paper we focus 1)
on the "doing by" functions and 2) on functions related to linear
estimates and contrasts. 



## Functions related to groupwise computations

### A working dataset - the `CO2` data

The `CO2` data frame comes  from an
experiment on the cold tolerance of the grass species _Echinochloa
crus-galli_.
To limit the amount of output we modify names and levels of variables
as follows

```{r}
data(CO2)
CO2 <- within(CO2, {
    Treat <- Treatment
    Treatment <- NULL
    levels(Treat) <- c("nchil", "chil")
    levels(Type)  <- c("Que", "Mis")
})
CO2 <- subset(CO2, Plant %in% c("Qn1", "Qc1", "Mn1", "Mc1"))
dim(CO2)
head(CO2, 4)
```

### The `summaryBy` function

The `summaryBy` function is used for calculating quantities like _the
mean and variance of numerical variables `x` and `y` for each
combination of two factors `A` and `B$`_.  Notice: A functionality
similar to `summaryBy` is provided by `aggregate` from base R, but `summaryBy` offers additional features. 


```{r}
myfun1 <- function(x){c(m=mean(x), s=sd(x))}
summaryBy(cbind(conc, uptake, lu=log(uptake)) ~ Plant, data=CO2, FUN=myfun1)
## same as
## aggregate(cbind(conc, uptake, log(uptake)) ~ Plant, data=CO2, FUN=myfun1)
```

The convention is that variables that do not appear in the dataframe (e.g. `log(uptake)`) must be named (here as `lu`). 
Various shportcuts are available, e.g. the following, where 
left hand side dot refers to "all numeric variables" while the
right hand side dot refers to "all factor variables". Writing `1` on the right hand side leads to computing over the entire dataset:

```{r}
summaryBy(. ~ ., data=CO2, FUN=myfun1)
summaryBy(. ~ 1, data=CO2, FUN=myfun1)
```


### Formulas and lists

The convention for the "By"-functions is that a two sided formula like can be written in two ways:
```{r, eval=FALSE}
cbind(x, y) ~ A + B
list(c("x", "y"), c("A", "B"))
```

Some "By"-functions only take a right hand sided formula as input. Such a formula can also be written in two ways:
```{r, eval=FALSE}
~ A + B
c("A", "B")
```

The list-form / vector-form is especially useful if a function is invoked programatically. Hence the calls to `summaryBy` above can also be made as

```{r, eval=FALSE}
summaryBy(list(c("conc", "uptake", "lu=log(uptake)"), "Plant"), data=CO2, FUN=myfun1)
summaryBy(list(c("."), c(".")), data=CO2, FUN=myfun1)
summaryBy(list(c("."), c("1")), data=CO2, FUN=myfun1)
```


### The `orderBy` function

Ordering (or sorting) a data frame is possible with the `orderBy`
function.  Suppose we want to order the rows of the the `CO2` data by
increasing values of `conc` and decreasing value of `uptake` (within `conc`):
```{r}
x1 <- orderBy(~ conc - uptake, data=CO2)
head(x1)
```

Following the remarks about specification in "By"-functions, an equivalent form is:
```{r, eval=F}
orderBy(c("conc", "-uptake"), data=CO2) 
```

### The `splitBy` function

Suppose we want to split `CO2` into a list of dataframes:

```{r}
x1 <- splitBy(~ Plant + Type, data=CO2)
x1
```

The result is a list (with a few additional attributes):
```{r}
lapply(x1, head, 2)
```


### The `subsetBy` function


Suppose we want to select those rows within each treatment for which  the
uptake is larger than 75% quantile of uptake (within the treatment). This
is achieved by:

```{r}
x2 <- subsetBy(~ Treat, subset=uptake > quantile(uptake, prob=0.75), data=CO2)
head(x2, 4)
```

### The `transformBy` function

The `transformBy` function is analogous to the `transform`
function except that it works within groups. For example:

```{r}
x3 <- transformBy(~ Treat, data=CO2, 
                 minU=min(uptake), maxU=max(uptake),
                 range=diff(range(uptake)))
head(x3, 4)
```

### The `lmBy` function

The `lmBy` function allows for fitting linear models to different strata of data (the vertical bar is used for defining groupings of data):
```{r}
m <- lmBy(uptake ~ conc | Treat, data=CO2)
coef(m)
```

The result is a list with a few additional attributes and the list can be processed further as e.g.
```{r}
lapply(m, function(z) coef(summary(z)))
```


## Functions related linear estimates and contrasts

A linear function of a $p$--dimensional parameter vector $\beta$ has
the form
\begin{displaymath}
  C=L\beta
\end{displaymath}
where $L$ is a $q\times p$ matrix which we call the `Linear Estimate Matrix` or 
simply `LE-matrix`.  The corresponding
linear estimate is $\hat C = L \hat \beta$.  A linear hypothesis has
the form $H_0: L\beta=m$ for some $q$ dimensional vector $m$.


### A working dataset - the `ToothGrowth` data

The response is the length of odontoblasts cells (cells responsible for
tooth growth) in 60 guinea pigs.  Each animal received one of
three dose levels of vitamin C (0.5, 1, and 2 mg/day) by one of
two delivery methods, (orange juice (coded as OJ) or ascorbic acid 
(a form of vitamin C and (coded as VC)). The dataset is balanced with 10 measurements for each combination of `dose` and `supp`. To illustrated certain points in what follows we make data unbalance by removing the some rows of the dataframe:

```{r}
data("ToothGrowth")
ToothGrowth <- transform(ToothGrowth, dose = factor(dose))
ToothGrowth <- ToothGrowth[-(1:3), ]
head(ToothGrowth, 4)
```



```{r linear:interaction2, echo=F, fig.height=2, fig.cap="Interaction plot for the ToothGrowth data. The average `len` for each group is a dot. Boxplot outliers are crosses."}
toothInt <- summaryBy(len ~ dose + supp, data=ToothGrowth)
ggplot(ToothGrowth, aes(x = factor(dose), y = len, colour = supp)) +
    geom_boxplot(outlier.shape = 4) +
    geom_point(data = toothInt, aes(y = len.mean)) +
    geom_line(data = toothInt, aes(y = len.mean, group = supp))
```

The interaction plot indicates some interaction between `dose` and `supp`.
This is also supported by a formal test:
```{r}
tooth1 <- lm(len ~ dose + supp, data=ToothGrowth)
tooth2 <- lm(len ~ dose * supp, data=ToothGrowth)
anova(tooth1, tooth2)
```

### Computing linear estimates

For now, we focus on the additive model. 
Consider computing the estimated length for each dose of orange juice (OJ):
One option: Construct the LE--matrix $L$ directly and then invoke `linest`:

```{r}
L <- matrix(c(1, 0, 0, 0, 
              1, 1, 0, 0,
              1, 0, 1, 0), nrow=3, byrow=T)
```

The matrix $L$ can be generated as follows:
```{r, eval=FALSE}
L <- LE_matrix(tooth1, effect="dose", at=list(supp="OJ"))
```

The estimates can be computed directly as 
```{r, eval=FALSE}
L %*% coef(tooth1)
```
but we do not obtain standard errors etc. this way. Instead we can invoke `linest`
```{r}
c1 <- linest(tooth1, L)
coef(c1)
confint(c1)
```

The function `esticon` has been part of `doBy` for many years while `linest` is a newer addition. The functionality, however, is similar:
```{r}
c1 <- esticon(tooth1, L)
c1
```

### Least-squares means (LS--means)

A related question could be: What is the estimated length for each
dose if we ignore the source of vitamin C (i.e.\ whether it is OJ or
VC). One approach would be to fit a model in which source does not appear:

```{r}
tooth0 <- update(tooth1, . ~ . - supp)
L0 <- LE_matrix(tooth0, effect="dose")
L0
linest(tooth0, L=L0)
```

An alternative would be to stick to the original model but compute the
estimate for an ``average vitamin C source''. That would correspond to
giving weight $1/2$ to each of the two vitamin C source
parameters. However, as one of the parameters is already set to zero
to obtain identifiability, we obtain the LE--matrix $L$ as

```{r}
L1 <- matrix(c(1, 0, 0, 0.5, 
               1, 1, 0, 0.5,
               1, 0, 1, 0.5), nrow=3, byrow=T)
linest(tooth1, L=L1)
```

Such a particular linear estimate is sometimes called a _least-squares
mean_, an _LSmean_, a _marginal mean_ or a _population mean_. 
Notice: One may generate $L$ automatically with
```{r}
L1 <- LE_matrix(tooth1, effect="dose")
L1
```

Notice: One may obtain the LSmean directly as:
```{r}
LSmeans(tooth1, effect="dose")
```
which is the same as
```{r, eval=FALSE}
L <- LE_matrix(tooth1, effect="dose")
linest(tooth1, L=L)
```

### Interaction model

For a model with interactions, the LSmeans are
```{r}
LSmeans(tooth2, effect="dose")
```

In this case, the LE--matrix is
```{r}
L <- LE_matrix(tooth2, effect="dose")
L
```



### Using (transformed) covariates

Below, the covariate `conc` is fixed at the average value:
```{r}
co2.lm1 <- lm(uptake ~ conc + Type + Treat, data=CO2)
LSmeans(co2.lm1, effect="Treat")
```

If we use `log(conc)` instead we will get an error when
calculating LS--means because `log(conc)` is not a variable in the dataframe. 
Instead one can do:
```{r}
co2.lm2 <- lm(uptake ~ log.conc + Type + Treat,
             data=transform(CO2, log.conc=log(conc)))
LSmeans(co2.lm2, effect="Treat")
```

This also highlights what is computed: The average of the log of
`conc`; not the log of the average of `conc`.
In a similar spirit consider

```{r}
co2.lm3 <- lm(uptake ~ conc + I(conc^2) + Type + Treat, data=CO2)
LSmeans(co2.lm3, effect="Treat")
```

Above \verb'I(conc^2)' is the average of the squared values of
`conc`; not the  square of the average of
`conc`, cfr.\ the following.

```{r}
co2.lm4 <- lm(uptake ~ conc + conc2 + Type + Treat, data=
              transform(CO2, conc2=conc^2))
LSmeans(co2.lm4, effect="Treat")
```

If we want to evaluate the LS--means at `conc=10` then we can do:
```{r}
LSmeans(co2.lm4, effect="Treat", at=list(conc=10, conc2=100))
```


## Alternative models


### Linear mixed effects model

For the sake of illustration we treat \verb|supp| as a random effect:
```{r}
library(lme4)
tooth.mix <- lmer(len ~ dose + (1|supp), data=ToothGrowth)
LSmeans(tooth.mix, effect="dose")
```

Notice here that the parameter estimates themselves are similar to those of a linear model (had data been completely balanced, the estimates would have been identical). However, the standard errors of the the estimates are much larger under the mixed model.
This comes from that `supp` is treated as a random effect.
Notice that the degrees of freedom by default are adjusted using a
Kenward--Roger approximation (provided that `pbkrtest` package [@pbkrtest] is
installed). Adustment of degrees of freedom is controlled with the `adjust.df` argument.

### Generalized linear models and generalized estimating equations

We can calculate LS--means for e.g.\ a Poisson or a gamma model. Notice that the LS--means are on the scale of the linear predictor - not on the scale of the response.

```{r}
tooth.gam <- glm(len ~ dose + supp, family=Gamma, data=ToothGrowth)
LSmeans(tooth.gam, effect="dose")
```

Similarly, for gee-type models we get:
```{r}
library(geepack)
tooth.gee <- geeglm(len ~ dose, id=supp, family=Gamma, data=ToothGrowth)
LSmeans(tooth.gee, effect="dose")
```



## Acknowledgements

Credit is due to Dennis Chabot, Gabor Grothendieck, Paul Murrell, Jim
Robison-Cox and Erik Jørgensen for reporting various bugs and
making various suggestions to the functionality in the `doBy`
package.



\bibliography{RJreferences}


<!-- ## Summary -->

<!-- This file is only a basic article template. For full details of _The R Journal_ style and information on how to prepare your article for submission, see the [Instructions for Authors](https://journal.r-project.org/share/author-guide.pdf). -->




<!-- ```{r} -->

<!-- mtcars <- within(mtcars, { -->
<!--    vs <- factor(vs, labels = c("V", "S")) -->
<!--    am <- factor(am, labels = c("auto", "man")) -->
<!-- }) -->
<!-- mtcars$drat <- mtcars$disp <- mtcars$wt <- mtcars$carb <- mtcars$gear <- NULL -->
<!-- mtcars <- subset(mtcars, cyl < 8) -->
<!-- mtcars %>% head -->
<!-- ``` -->





<!-- ```{r} -->
<!-- library(doBy) -->
<!-- summaryBy(cbind(mpg, qsec) ~ cyl + vs, data=mtcars) -->

<!-- summaryBy(list(c("mpg", "qsec"), c("cyl", "vs")), data=mtcars) -->

<!-- summaryBy(. ~ cyl + vs, data=mtcars) -->

<!-- summaryBy(. ~ ., data=mtcars) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- ss <- splitBy(~ vs, data=mtcars) -->
<!-- ss -->
<!-- ss$V -->
<!-- ``` -->


<!-- Introductory section which may include references in parentheses -->
<!-- [@R], or cite a reference such as @R in the text. -->

<!-- This section may contain a figure such as Figure \ref{fig:Rlogo}. -->

<!-- ```{r, Rlogo, echo=FALSE, fig.cap='The logo of R.', out.width='2in', fig.align='center', fig.pos='htbp'} -->
<!-- knitr::include_graphics('Rlogo.pdf') -->
<!-- ``` -->

<!-- There will likely be several sections, perhaps including code snippets, such as: -->

<!-- ```{r} -->
<!-- x <- 1:10 -->
<!-- x -->
<!-- ``` -->
